{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"Initializer Boilerplate": {
	"prefix": "Init",
	"body": [
		"# Template: https://codeforces.com/profile/kabeer27",
		"# Submit using pypy2",
		"from __future__ import division, print_function",
		"",
		"def solve():",
		"\tpass$0",
		"",
		"def main():",
		"\ttests = 1",
		"\ttests = int(input().strip())$1",
		"\tfor test in range(tests):",
		"\t\tsolve() ",
		"",
		"######## Python 2 and 3 footer by Pajenegod and c1729",
		"",
		"# Note because cf runs old PyPy3 version which doesn't have the sped up",
		"# unicode strings, PyPy3 strings will many times be slower than pypy2.",
		"# There is a way to get around this by using binary strings in PyPy3",
		"# but its syntax is different which makes it kind of a mess to use.",
		"",
		"# So on cf, use PyPy2 for best string performance.",
		"",
		"py2 = round(0.5)",
		"if py2:",
		"\tfrom future_builtins import ascii, filter, hex, map, oct, zip",
		"\trange = xrange",
		"",
		"import os, sys",
		"from io import IOBase, BytesIO",
		"",
		"BUFSIZE = 8192",
		"class FastIO(BytesIO):",
		"\tnewlines = 0",
		"",
		"\tdef __init__(self, file):",
		"\t\tself._file = file",
		"\t\tself._fd = file.fileno()",
		"\t\tself.writable = \"x\" in file.mode or \"w\" in file.mode",
		"\t\tself.write = super(FastIO, self).write if self.writable else None",
		"",
		"    def _fill(self):",
		"        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))",
		"        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])",
		"        return s",
		"",
		"    def read(self):",
		"        while self._fill(): pass",
		"        return super(FastIO,self).read()",
		"",
		"    def readline(self):",
		"        while self.newlines == 0:",
		"            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)",
		"        self.newlines -= 1",
		"        return super(FastIO, self).readline()",
		"",
		"    def flush(self):",
		"        if self.writable:",
		"            os.write(self._fd, self.getvalue())",
		"            self.truncate(0), self.seek(0)",
		"",
		"class IOWrapper(IOBase):",
		"    def __init__(self, file):",
		"        self.buffer = FastIO(file)",
		"        self.flush = self.buffer.flush",
		"        self.writable = self.buffer.writable",
		"        if py2:",
		"            self.write = self.buffer.write",
		"            self.read = self.buffer.read",
		"            self.readline = self.buffer.readline",
		"        else:",
		"            self.write = lambda s:self.buffer.write(s.encode('ascii'))",
		"            self.read = lambda:self.buffer.read().decode('ascii')",
		"            self.readline = lambda:self.buffer.readline().decode('ascii')",
		"",
		"",
		"sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)",
		"input = lambda: sys.stdin.readline().rstrip('\\r\\n')",
		"",
		"# Cout implemented in Python",
		"import sys",
		"class ostream:",
		"    def __lshift__(self,a):",
		"        sys.stdout.write(str(a))",
		"        return self",
		"cout = ostream()",
		"endl = '\\n'",
		"",
		"# Read all remaining integers in stdin, type is given by optional argument, this is fast",
		"def readnumbers(zero = 0):",
		"    conv = ord if py2 else lambda x:x",
		"    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()",
		"    try:",
		"        while True:",
		"            if s[i] >= b'0' [0]:",
		"                numb = 10 * numb + conv(s[i]) - 48",
		"            elif s[i] == b'-' [0]: sign = -1",
		"            elif s[i] != b'\\r' [0]:",
		"                A.append(sign*numb)",
		"                numb = zero; sign = 1",
		"            i += 1",
		"    except:pass",
		"    if s and s[-1] >= b'0' [0]:",
		"        A.append(sign*numb)",
		"    return A",
		"",
		"if __name__== \"__main__\":",
		"  main()"
	],
	"description": "Initializer Boilerplate Template"
	}
}